# Пункт 1.1

# Инициализация переменных
N = 1000            # Количество клиентов
K = 10              # Максимально возможная страховая выплата
V = 6600            # Имеющийся у компании резерв

A <- 1 / integrate(function(x) (x ^ 3) * (K - x), 0, K)$value   # параметр A для функции f(x)
n = 100             # Количество итераций

# Функция плотности распределения страховых выплат
f = function(x) {
  A * (x ^ 3) * (K - x)
}

# Максимальное значение плотности распределения
M = max(sapply(0:K, f))

# Вектор сумм выплат для каждой итерации
S <- c()

# Генерация значений от плотности распределения f(x) методом Неймана
Neumon <- function(count_value) {
  # вектор значений
  x <- c()
  for(j in 1:count_value)
  {
    # генерация значений x1 и x2
    u1 <- runif(1, min =  0, max =  1)
    u2 <- runif(1, min =  0, max =  1)
    x1 = K * u1
    x2 = M * u2 
    
    # повторно генерируем, пока не выполнится критерий
    while(x2 > f(x1))
    {
      u1 <- runif(1, min =  0, max =  1)
      u2 <- runif(1, min =  0, max =  1)
      x1 = K * u1
      x2 = M * u2 
    }
    
    # запоминаем выплату
    x <- c(x, x1)
  }
  return(x)
}

# Генерация n выборок
for (i in 1:n)
{
  # заполнение вектора суммами выплат
  S <- c(S, sum(Neumon(N)))
}

# Подсчет вероятности разорения методом Монте-Карло
P <- sum(S > V) / n
cat("Вероятность разорения:", P)

# Подсчет вероятности разорения с помощью аппроксимации
# 
# Согласно ЦПТ, если даны независимые одинаково распределенные св,
#   имеющие конечные мат ожидание E и дисперсию D,
#   также сумму первых n элементов Sn,
#   то (Sn - n*E)/sqrt(n*D) ~ N(0,1)
# Тогда можно получить значение аппроксимации
#   с помощью функции Лапласа от (Sn - n*E)/sqrt(n*D)

# Вычисление математического ожидания и дисперсии
EX <- integrate(function(x) x * f(x), 0, K)$value
DX <- integrate(function(x) (x - EX) ^ 2 * f(x), 0, K)$value

# Определение функции Лапласа
Fl = function(x){1 / sqrt(2 * pi) * integrate(function(y) exp(- ((y ^ 2)/2)), 0, x)$value}

# Аппроксимация вероятности разорения
Pa = 1 / 2 - Fl((V - N * EX) / sqrt(N * DX))
Pa = 1 - pnorm((V - N * EX) / sqrt(N * DX))

# Вывод результатов
cat("Аппроксимация:", Pa)

################################################################################

# Отрисовка

values <- Neumon(1000)
plot(x = values, y = sapply(values, f))
